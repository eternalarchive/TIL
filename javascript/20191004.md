2019-10-04

### 러버덕 발표시간

#### 주제 : 웹 브라우저 동작원리

- DOM Tree 와 CSSOM Tree가 이벤트 등에 의해 변하면 다시 Render Tree를 만듦
  - 바뀐 부분만 새로 그리는 것이 가장 합리적
  - 브라우저들은 그렇게 하지 못하므로 리액트가 인기를 끌고 있음
- 선생님이 이 주제로 러버덕을 내주신 이유 : 웹 브라우저 동작원리를 통해 스크립트 태그 위치가 왜 바디 하단인지 알기 위해
  - 추후 DOM 다시 배울 때 자세히 설명



### ESlint

- LF / CRLF : 우리는 LF로 설정을 맞출 것
- 코딩은 자폭을 맞춰주어야 함 : 인덴트를 쓸 때 가지런하지 않을 수 있음



# 4. 변수

### 1. 변수란 무엇인가? 왜 필요한가

- **변수** : 하나의 값을 저장할 수 있는 **메모리** 공간에 붙인 이름 또는 메모리 공간 자체

- 우리가 하는 일을 짧게 말하자면, 데이터를 다루는 것
- 값을 저장하는 메커니즘



- 자바스크립트 코드는 어디서 실행시키는가?
  - 브라우저 개발자 도구 콘솔
  - node.js (터미널-node)
  - html파일에 script태그 사용(바디 안에 아무것도 없으면 화면엔 출력되지 않음)



- CPU : 연산

- 메모리 : 기억 -> 데이터 저장
  - 1byte단위로 저장(유의미한 데이터가 되려면 최소 1byte - 아스키코드 할 때 배웠음) - 1byte단위의 메모리 셀을 가지고 있음
  - 메모리 셀마다 주소(memory address)가 존재(기억한 값을 꺼내오기 위해)
  - 자바스크립트 엔진이 연산을 시작하면 CPU에게 10, 20을 기억해달라고 요청하면 CPU가 빈 셀에 값을 저장 -> CPU가 이 값을 읽어들여 계산한 후 새로운 값을 생성하여 빈 셀에 저장
- 10 + 20이라는 자바스크립트 코드가 실행되면 자동적으로 메모리에 기억된 데이터와 연산 그림이 생각나야 함
  - 30이란 값이 필요하므로 연산을 했음
  - 30이란 값에 접근하려면 메모리 주소를 알아야 접근할 수 있음
    - 그런데 우리에게 알려주지 않음 -> 사람은 실수를 하므로
    - OS가 사용중인 메모리 주소라도 접근하여 값을 바꿔버리게 되면 **치명적인 문제 발생**
    - 실행할 때마다 30 메모리 주소는 다 다르므로 꺼내올 수 없음
  - 그러므로 **변수를 활용**하자!
    - 변수는 메모리 주소를 기억하고 있음
- **변수** : 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체
  - 이름이면 이름이고 공간이면 공간이지 차이는 무엇인가?
    - 호텔 101호로 예를들면, 101호는 방의 위치. 위치를 알면 공간으로 찾아갈 수 있음. 그러므로 공간의 이름이자 메모리 공간으로 인식 가능
- 변수에는 하나의 값만 저장할 수 있음!
  - 값은 메모리에 들어가는 대상
- 변수에 여러개의 값을 넣고 싶다면?
  - **배열이나 객체와 같은 *자료 구조*를 사용**하면 관련 있는 여러 개의 값을 그룹화하여 하나의 값처럼 사용 가능
- 변수 이름(식별자)도 고유한 이름을 가져아 함(id처럼)

```javascript
// 30이라는 값이 result라는 변수에 할당(assign)된다 or 저장된다 or 대입된다
var result = 10 + 20;
```

- 여기서 var는 키워드. 명령어
  - var 뒤에 변수 명을 쓰면 해당 변수에게 방을 하나 주어라(호텔 카드키 주듯)
- 과정 : 10, 20이 메모리 셀에 저장된 후 cpu로 연산되어 생성된 값 30을 좌항의 result에 할당
  - 10, 20을 연산하여 생성된 값 30을 평가되었다고 말할 수 있음
  - 이 과정이 끝난 후 10, 20은 필요가 없으므로 지워야 함 -> 가비지 콜렉터
  - 가비지 콜렉터가 계속 메모리 셀에 담긴 값을 쓰는지 안쓰는지 지켜봄
- 할당(assignment)과 참조(Reference)
  - 변수에 값을 저장하는 것 : 할당
  - 변수에 저장된 값을 읽어들이는 것 : 참조

```javascript
var result = 10 + 20; // undefined <- 할당
result // 30 <- 참조
// 만약 진짜 코드파일에서 result만 쓰면 값이 안나오고 console.log(result)를 통해 실행해야 한다.
```

- **변수 이름**과 값은 항상 매핑관계이므로 **값을 의미**해야 함
  - result라는 변수명은? 대체 무엇의 결과인데? -> 좋지 않은 변수명

- 위 코드 확인해보는 방법
  - 콘솔
  - 터미널 node
  - vs code 터미널에서 node app
  - vs code 확장 프로그램 code runner 사용하기(단축키 : control^+option+N) -> DOM API가 없을 때
  - vs code 확장 프로그램 Quokka.js 사용하기(단축키 : 커맨드 + 쉬프트 + P) - Quokka.js:start on current file 켜놓으면 바로 확인 가능
    - 단 코드가 짧을 때 사용하도록 하자



### 2. 식별자

- 변수 이름만 식별자가 아니라 변수, 함수, 클래스 등의 이름 모두가 식별자
- 식별자 이름은 함부로 지을 수 없고, 식별자 네이밍 규칙에 따라 지어야 함



### 3. 변수 선언

- 자바스크립트 엔진에 **변수 이름**을 알려 등록하고 변수값을 저장하기 위한 **메모리 영역의 확보**를 명령하여 값을 저장할 수 있도록 준비하는 것

```javascript
// 문법적 설탕(사람이 쓰기 쉽게), 위와 아래는 동치 관계다.
var result;
result = 100;

var result = 100;
```

- 선언 안해도 할당을 할 수 있을까?
  - 자바스크립트는 할 수 있지만 사용하지 않는 것이 좋다.

- 변수는 선언만하고 할당을 하지 않으면 자바스크립트 엔진에 의해 *암묵적으로* **undefined 값**(undefined도 값임)을 갖음
  - 자바스크립트 엔진이 암묵적으로 하는 일이 많다면?
    - 편하지만 코드에 대한 예측이 어려워짐
- 개발자가 의도적으로 undefined 값을 할당할 일은 없음(해서도 안됨)
  - undefined는 선언만하고 *할당하지 않았음을 알려주는 것*이고, 만약 빈 공간을 할당하고 싶다면 null값을 할당해야 함
  - 자바스크립트 엔진이 쓰려고 만든 값이므로 우리는 뜻을 이해하기만 하면 됨
- var 키워드를 사용한 변수 선언은 **선언단계와 초기화단계가 동시에 진행**
  - let, const는 초기화단계가 조금 다름
- 자바스크립트 에러는 런타임 때 남(컴파일언어는 컴파일타임에 - 컴파일 언어는 할당하지 않은 변수를 참조한 경우 에러나서 실행되지 않음)
  - 인터프리터 언어의 약점
  - (런타임에 에러가 나므로 사용자가 에러를 만나지 않게 하기 위해)최대한 에러를 안나게 설계하려다보니 할당하지 않은 변수에 undefined 값을 암묵적으로 할당하게 됨
  - ES6에서 이를 개선하고자 let, const 변수 도입
- 선언 안한 상태에서 참조 : ReferenceError 참조 에러 발생
- **실행 컨텍스트(execution context) : 자바스크립트 엔진에 의해 선언된 식별자가 등록되는 곳.**
  - 자바스크립트 엔진이 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역

- 실행 컨텍스트가 식별자를 관리해야 하므로 자바스크립트 엔진이 실행 컨텍스트에 식별자 이름을 등록함 - 누군가 식별자를 관리하고 있다 정도만 이해하고 나중에 심화교육



### 4. 변수 선언의 실행 시점과 변수 호이스팅

> 변수 호이스팅을 모르는 개발자는.. 뭐지..? 할정도로 당연히 알아야 하는 개념

- **변수 호이스팅** : 변수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징

```javascript
console.log(score); // undefined

var score; // 변수 선언(변수 선언문)
```

- 코드를 한 줄 한 줄 실행하기 이전에 모든 선언문을 먼저 실행
  - 코드를 실행하기 앞서 **코드 평가**가 이루어짐 : 코드 실행 준비 단계
- 런타임에는 선언문을 빼고 실행함(이미 실행 했으므로)
- 변수 호이스팅을 활용하라고 알려주는게 아니라 쓰지 말라고 알려주는 것
- **왜 호이스팅이 발생**하는가? - 선언문 이전에 참조하여서

```javascript
console.log(result); // undefined
var result = 100;
console.log(result); // 100
```

- 왜 할당했는데 첫 번째 console.log(result);가 undefined인가?
  - 선언은 런타임 이전에, 할당은 런타임에 이루어지므로 위와 같은 결과

- 자바스크립트 에러는 대부분 런타임에 발생, **예외**는 뭘까?
  - 문법 에러는 미리 남
  - 컴파일 에러는 대부분 컴파일 타임에 발생(런타임에도 발생은 함)



### 5. 값의 할당

```javascript
console.log(score); // undefined

var score;  // 변수 선언
score = 80; // 값의 할당

console.log(score); // 80
```

- 한 줄로 var score = 80; 선언과 할당하는 것이 좋은데, 그 이유는 선언과 할당을 따로 할 경우 선언시에 undefined 값이 할당되어버리기 때문 - 엄밀히 말하면 재할당(메모리 공간 낭비)
  - undefinded 할당할 때 메모리 공간 차지
  - 80 할당시 undefined를 지우고 다시 쓰는 것이 아니라 또 다른 메모리 공간을 차지
- 값을 변경할 수 없다는 의미 : 원시값을 지우고 다시 못 쓴다는 이야기(undefined자리에 undefined를 지우고 다른 값을 못 씀, 새로운 메모리 공간에 써짐)
  - 원시값 : 수정할 수 없음
  - 원시값을 지우고 다시 쓰는 것 : 객체

```javascript
console.log(score); // undefined

score = 80; // 값의 할당
var score;  // 변수 선언

console.log(score); // 80 <- 이유를 설명할 수 있어야 한다
```

- 이미 런타임 이전에 선언문이 변수 호이스팅 되었으므로 초기화되지 않음



### 6. 값의 재할당

- 어떠한 식별자도 가지고 있지 않은 메모리 셀들은 가비지 콜렉터들에 의해 정리
- 언매니지드 언어와 매니지드 언어
  - C언어는 언매니지드 언어(개발자가 메모리 직접 관리)
  - 언매니지드 언어는 개발자의 수준이 높아야 함
  - 자바스크립트는 매니지드 언어



금요일 러버덕 : 키워드, 식별자, 변수와 선언, 메모리와 메모리구조, 할당
