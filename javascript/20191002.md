2019-10-02

###러버덕 발표시간

- 인터프리터 언어가 디버깅이 쉽다?
  - 실행할때 에러가 발생하므로사용자가 에러를 맞이할 확률이 높음
  - 오히려 디버깅은 컴파일러가 쉬움(실행되기 이전이므로)
- 아스키코드는 1byte=8bit
  - 이 중 1bit는 패리티비트로 7bit만 활용
- 아스키코드는 1byte밖에 안되서 표현할 수 있는 문자가 한정적이므로 2byte를 사용하여 2의 16승만큼 언어표현이 가능해졌으므로 세상의 모든 언어를 표현할 수 있게 되었음
- 아스키코드는 언제쓰고 유니코드는 언제쓸까?
  - 예전에는 아스키코드를 썼었으나 현재는 거의다 유니코드를 사용함
  - HTTP에서 아스키 코드를 사용함
- ECMAscript와 Javascript의 차이(비유적으로)
  - ECMA international : 국립국어원
  - ECMA - 262 : 표준말
  - ECMAScript(specification) : 맞춤법, 띄어쓰기
  - JavaScript: 서울말, 경상도말 ...
  - JavaScript 안에 ECMAScript가 포함



### 어제 수업 복습

- 일반적인 언어와 다른 자바스크립트의 독특한 특징
  - 웹 브라우저에서 동작하는 유일한 프로그래밍 언어
- 기계어 조차 프로그래밍 언어(대표적으로 어셈블리어)
  - 웹 어셈블리어를 만들자는 얘기가 나오고 있음(고사양 게임을 웹 브라우저에서 돌리고싶어)
- 대부분의 객체지향 언어는 클래스 기반으로 구현하는데, **자바스크립트는 프로토타입 기반**으로 구현
- 자바스크립트는 함수형 프로그래밍을 가능하게 하기 위해 함수가 값을 주고 받을 수 있음
- 자바스크립트는 엔진 : 자바스크립트를 실행할 수 있는 환경, 엔진
- **자바스크립트**는 명령형, 함수형, **프로토타입 기반 객체지향** 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어
- 모던 자바스크립트 엔진은 내부적으로 많이 쓰는 코드를 인식하고 미리 컴파일을 해 놓아서 인터프리터의 단점(속도)을 해결
  - 실행파일을 만들지 않으므로 자바스크립트는 인터프리터 언어라고 할 수 있음



##자바스크립트 개발 환경과 실행 방법

### 1. 자바스크립트 실행 환경

- 자바스크립트는 어디서 실행할까?
  - 웹 브라우저와 Node.js
  - 웹 브라우저와 Node.js는 용도가 다름
    - Client side API / Host API)



#### 잠시 코드 보며 듣는 시간

- html 태그는 부모가 없음. head와 body 두 자식만을 가짐.

- meta(앞에 있는, 우선한) : 컴퓨터 사이언스에서는 설정 정보같이 애플리케이션을 위한 데이터들을 메타 데이터라고 함

- body태그 내부는 뷰포트에 렌더링되는 요소들을 씀

- 시맨틱상 script태그는 head태그 안에 넣는게 맞음

  - 그러나 인터프리터 언어 특성상 위에서부터 순차적으로 실행되므로 위치상 바디태그 가장 하단에 넣어야 실행이 된다. body태그 안에 있는 태그를 읽기도 전에 head안에서 script에서 태그를 가져오려하면 순서상 알 수 없음

  - ```javascript
    const button = document.querySelector('button');
    ```

    - 여기서 document.querySelector('button')은 Web API

- **js가 DOM을 건들면 body밑에 있어야 하고**, DOM을 건들지 않으면 head안에 있어도 됨



### 2. 웹 브라우저

#### 2.1. 웹 브라우저는 어떻게 동작하는가? (필수로 알고 있자)

> ***졸업** 전까지 꼭 알고 있을 것*

- 클라이언트와 서버
  - 클라이언트(웹 브라우저) : 데이터 요청**(request)**
  - 서버 : 데이터 요청에 대한 응답**(Response)**
- 로딩(Loading) : 브라우저가 서버로부터 html/css/js파일을 다운로드 받음
- 도메인 : 서버를 식별할 수 있는 이름

- 웹 서버는 root로 요청이 오면 index.html을 주도록 되어 있음
  - www.naver.com으로 접속시 /index.html과 똑같이 동작

- HTTP : 모든 웹 서버는 이 규약으로 움직임
  - 그림으로 배우는 HTTP라는 책을 한 번 읽어보자(Ajax배울 때)

- 파일에서 Read는 메모리상에 올리는 것(컴퓨터는 눈이 없음)

- HTML 파싱의 결과물 : DOM Tree
- CSS 파싱의 결과물 : CSSOM Tree
- HTML/CSS 파싱은 브라우저에 있는 렌더링 엔진이 함(Webkit)
  - 자바스크립트는 별도의 엔진
- HTML의 특징 : 태그들이 **중첩**된다(여는 태그와 닫는 태그 사이에 또 다른 태그, 이미지, 텍스트를 넣을 수 있음)
  - 중첩의 의미 : 부자 관계 형성 -> 중첩을 통한 **정보의 구조화**

- 컴퓨터는 파일 만들 때 가장 많은 리소스를 씀
- HTTP 1.1은 파일을 한 개씩 가져오고 2.1은 한 방에 가져옴
  - 우린 왜 1.1로 썼는가? 일단 1.1을 알고 2.1을 배워야 하므로(기본적으로 파일을 한 개씩 가져온다는 것)

- (웹 브라우저의 동작 이미지 설명) HTML 파싱하다가 CSS를 만나면 -> 
  HTML 파싱을 중단 하고 CSS 파싱을 해서 CSSOM Tree를 만든 후 -> 
  다시 HTML 파싱을 하다가 JS를 만나면 파싱(AST Tree 생성)을 해서 JS를 바로 실행시키고(HTML DOM이 완성 되기도 전에) -> 
  다시 HTML 파싱을 해서 DOM Tree를 만들고 Tree를 합쳐 Render Tree를 만든다.
  - 여기까지 완료되면 painting
  - 성능을 생각하자 : 최대한 painting이 다시 일어나지 않도록 해야함(구글이 Ajax로 만들었던 구글맵처럼)

- HTTP는 단방향 통신 - 무전기로 예를 드셨는데 간단하게 설명하신 것(핸드폰 통화처럼 동시에 말할 수 없다)이므로 반이중 통신까진 가지 말자(질문)



*** 자바스크립트를 어떻게 파싱하는가?**

- simple :  JS소스코드 - 토큰 - AST 트리 생성 - 바이트코드(머신코드) - 실행
- 토큰(Token) : 코드를 최소 단위로 나눈 것(더 이상 나눌 수 없는 형태소와 같음)
- 키워드 : 예약어, 식별자 앞에 있어야 함
  - 자바스크립트가 예약어를 만나면 알아차림
- 바이트코드 = 어셈블리어 -> 인터프리터가 실행



*** script태그의 async / defer는 잘 사용하지 않음**

- script는 body태그 하단에 위치시키도록 하자



*** 좋은 코딩 습관** - 디버깅

- 체크하는 습관을 갖자
  - 짧은 코드는 console.log();로 확인해보기
  - 긴 코드는 디버깅 해보기
- Sources 탭에서 html을 눌러보면 빨간색 밑줄로 에러 위치를 표시해줌
  - 오른쪽 빨간엑스에 마우스를 올려보면 에러메시지가 뜸
    - 대부분 에러메시지 위쪽에서 에러가 발생(인터프리터 성격을 생각해보자) - 비동기방식일 경우 아래에서 발생하기도 함

> 선생님 코드보며 개발자 도구에서 에러 찾기

- 에러 원인 찾기 - 첫라인 왼쪽 번호를 클릭하면 브레이크포인트(중단점) 생성
  - 재실행 해보면 코드가 해당 라인까지만 해석되고 stop
  - 오른쪽 상단에 휘어진 화살표아래 점찍힌 기호를 누르면 해당 줄은 해석 되고 다음줄로 넘어가므로 해당 줄의 변수에는 값이 담겨있음
  - button값이 null임을 알려줌
    - null의 의미 : 쿼리셀렉터를 잘못 썼거나, 정말 없거나



*** ESlint 코딩 컨벤션을 전역에 설치하지 않는 이유**

- 프로젝트마다 지켜야 할 rule이 다를 수 있으므로
- 코딩 컨벤션이 없는 회사는 좋지 않은 회사



금요일 수업 : 변수, 데이터 타입, 연산자(많이 나가면)

금요일 러버덕 : 웹 브라우저 동작