2019-10-07

### 러버덕 시간

- 누군가 나에게 **변수**란 무엇인가? 라고 물었을 때
  - '메모리'라는 단어가 나와야 함
  - 하나의 값을 저장할 수 있는 **메모리 공간에 붙인 이름 또는 메모리 공간 자체**

**변수명**

```javascript
var first-name; // SyntaxError: Unexpected token –
var 1st;        // SyntaxError: Invalid or unexpected token
var this;       // SyntaxError: Unexpected token this
```

- 첫 번째 에러 : first까지 식별자로 인식, -를 산술연산자로 인식한 것. 토큰 '-'를 왜 썼는지 모르겠다는 것
- 두 번째 에러 : 식별자 첫글자에 숫자가 오면 안됨
- 세 번째 에러 : 식별자에 예약어 사용하면 안됨

```javascript
var FIRSTNAME;
```

- 식별자명을 전부 대문자로 쓰면 개발자끼리 암묵적으로 상수구나 하고 이해함

- 주석은 없을 수록 좋음 : 변수 이름을 잘 지어라

**주로 쓰이는 네이밍 규칙**

> ECMAScript 사양에 정의된 표준 빌트인 객체와 전역 함수들도 카멜 케이스와 파스칼 케이스 네이밍 컨벤션 사용

- 카멜 케이스 : 변수명 함수명
- 파스칼 케이스 : 생성자 함수명 클래스



# 5. 데이터 타입

## 1. 데이터 타입이란 무엇인가? 왜 필요한가?

- 데이터 타입(= 타입) : 값의 종류
  - 그렇다면 **값**(value)은? : 메모리에 저장되는 그 자체

- 10 + 20 이 표현식을 평가하여 값 30을 만듦
- **평가**를 하면 항상 **값**이 만들어짐

```javascript
var a = 10 + 20; // 메모리 공간에 평가된 값 30이 저장 된다.
```

- **타입이 필요한 세 가지 이유**
  - 할당할 때 타입에 의한 메모리 공간의 확보
  - 값을 참조할 때 한번에 읽어들여야 할 메모리 공간의 크기를 결정
  - 데이터 타입에 의한 값의 해석(컴퓨터에는 2진수만)

### 1.1 데이터 타입에 의한 메모리 공간의 확보

- 타입마다 확보해야 될 메모리 공간의 크기가 제각각임(타입을 모르면 확보해야 할 메모리 공간의 사이즈를 알 수 없음)

- 자바스크립트는 숫자값을 저장할 때 8byte 사용(메모리 셀 8개 사용)

- 숫자의 경우 선두로 들어가서 8byte를 확보해야 데이터 손실이 없음



## 2. 값

> 표현식 -> 평가 -> 값

- **값(value)** : 더 이상 평가할 수 없는 하나의 표현식
  - 값은 반드시 타입을 갖음
  - 변수에 할당할 수 있음
- 모든 값은 표현식! : 평가되어 나타내어진 값이므로!
- 평가(evaluation)의 결과물 : 값
- 표현식(expression, 식) : 값을 생성하는 문(평가되어 값을 생성)
  - 하나 이상의 리터럴, 하나 이상의 표현식, 연산자 등으로 구성되어 있는 문
  - 표현식은 자바스크립트 엔진에 의해 **평가되어 새로운 값을 생성하는 문**

```javascript
// 10 + 20은 표현식이다. 이 표현식은 평가되어 30이라는 값을 만든다.
10 + 20

// 변수에는 표현식 10 + 20의 평가되어 생성한 값 30이 할당된다.
// 10 + 20이 할당되는 것이 아닌 평가된 값 30이 할당됨을 주의하자.
var sum = 10 + 20;

// 이 경우 평가 과정이 이루어지는가? 그렇다. 사람의 눈은 20임을 바로 알지만, 컴퓨터는 리터럴 표기법에 의해 쓰여진 20을 평가하여 20을 만들어 낸다.
var sum = 20;
```



## 3. 값의 생성

> 값의 생성 방법 : 리터럴 표기법, 표현식
>
> > 표현식(expression, 식)이란? : 하나 이상의 리터럴, 하나 이상의 표현식, 연산자 등으로 구성되어 있는 문

### 3.1 리터럴

- 리터럴(literal) : 소스 코드 안에서 직접 만들어낸 고정된 값 자체
  - 리터럴 표기법(literal notation)으로 생성 : *값을 생성하는 방법*

#### 3.1.1 리터럴 표기법을 통한 값의 생성

- 리터럴 표기법으로 값의 생성을 자바스크립트 엔진에게 명령
- 숫자 리터럴 표기법 : 숫자를 만들어내는 가장 간단한 표기법
- 문자열 리터럴 표기법 : 작은 따옴표가 관례

- null : 의도적 부재, 변수에 값이 없음을 나타내기 위해 변수에 값을 넣는 것
- symbol : 여러개의 프로퍼티들이 나열되어 있는 것(나중에 자세히 배울 것)
- 객체(나중에 자세히 배울 것)

```javascript
// 객체 리터럴
{ name: 'Lee', address: 'Seoul' }
```

- 자바스크립트는 모든 수를 실수 처리 함
  - 실수 : 허수가 아닌 것들
  - 허수 : 루트 -1과 같이 현실에는 있을 수 없는 값

```javascript
// 표기법만 다를 뿐 같은 값이다.
console.log(0b01000001 === 65);    // true
console.log(0b01000001 === 0o101); // true
console.log(0b01000001 === 0x41);  // true
```

- 10진수, 2진수, 8진수, 16진수 등 모두 사람을 위한 표기법일 뿐 컴퓨터는 모두 2진수로 처리

#### 3.1.2 값과 리터럴의 관계

- 숫자 리터럴 : 평가되어짐 -> 값이 됨
  - 동치 관계

### 3.2 표현식

- 표현식(expression) : **평가**되어져서 **하나의 값**을 생성하는 것들
  - 하나의 값으로 평가될 수 있는 문(statement)
- 리터럴(모든 리터럴), 식별자, 연산자, 함수 호출 등의 조합

```javascript
var a = 10;
var b = a; // 10
```

- a는 평가되어 10을 만들어 냄 -> 식별자도 표현식
- 리터럴은 표현식이지만, 표현식이 모두 리터럴인 것은 아님



## 4. 데이터 타입의 분류

> ES6는 7개의 타입 제공 - 외울 것

- 원시 타입(primitive type) : 숫자, 문자열, 불리언, undefined, null, symbol
- 객체 타입(object/referenve type) : 객체, 함수, 배열 등



## 5. 숫자 타입

- ECMAScript 사양에 따르면 숫자 타입의 값은 64비트 부동소수점 형식을 따름
  - 모든 수를 실수 처리
- 추가적으로 3가지 특별한 값
  - Infinity : 양의 무한대
  - -Infinity : 음의 무한대
  - NaN : 산술 연산 불가(not-a-number)



## 6. 문자열 타입

- 문자열은 0개 이상의 16bit 유니코드 문자들의 집합

```javascript
// 문자열 타입
var string;
string = "문자열"; // 큰 따옴표
string = '문자열'; // 작은 따옴표
string = `문자열`; // 백틱 (ES6)

string = "큰 따옴표로 감싼 문자열 내의 '작은 따옴표'는 문자열로 인식된다.";
string = '작은 따옴표로 감싼 문자열 내의 "큰 따옴표"는 문자열로 인식된다.';

// 따옴표로 감싸지 않은 hello를 식별자로 인식한다.
var string = hello; // ReferenceError: hello is not defined
```

### 6.1 템플릿 리터럴

- 백틱(backtick) 문자 사용
  - 내부에 작은 따옴표, 큰 따옴표 혼용 가능
- 일반적인 문자열에서 줄바꿈은 허용되지 않으며 공백을 표현하기 위해서는 백슬래시로 시작하는 이스케이프 시퀀스(Escape Sequence)를 사용
- 이스케이프 시퀀스
  - \t : 탭, \n : 개행 등
- 문자열 + 문자열 연산시 ES5와 ES6의 방식이 다름
  - 문자열 인터폴레이션(String Interpolation) : 새로운 문자열 삽입 기능
  - 문자열 인터폴레이션을 사용할 경우 ${ }는 반드시 백틱문자 안쪽에 사용하여야 함

```javascript
var first = 'Ung-mo';
var last = 'Lee';

// ES5: 문자열 연결
console.log('My name is ' + first + ' ' + last + '.');
// My name is Ung-mo Lee.

// ES6: String Interpolation
console.log(`My name is ${first} ${last}.`);
// My name is Ung-mo Lee.
```

- 문자열 인터폴레이션은 ${ }으로 표현식을 감싸는데, 이 때 표현식의 평가 결과는 문자열로 강제 타입 변환 됨

```javascript
console.log(`1 + 1 = ${1 + 1}`); // 1 + 1 = 2
```

- 암묵적 타입 변환을 캐치하지 못하면 오류가 많아질 수 있음



## 7. 불리언 타입

- 참, 거짓을 나타내는 true, false 뿐



## 8. undefined 타입

- 선언 후 할당이 이루어지지 않았을 때 자바스크립트 엔진이 초기화 한 값
- 선언(Declaration)과 정의(Definition)
  - 선언(Declaration) : 우리 수업에서는 변수를 선언이라 부를 것. undefined값이 들어가긴 하지만 정의되지는 않음
  - 정의(Definition) : 무언가를 명확히 나타내는 것으로, 컴퓨터 공학쪽에서는 변수에 값을 할당하여 그 변수가 어떤 값을 가지고 있는지 명확하게 나타내는 것을 의미
    - 우리 수업에서는 함수를 정의라 부를 것 : 선언과 동시에 정의됨
  - 자바스크립트에서는 선언과 정의의 구분이 모호함



## 9. null 타입

- 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재 Interntional absence)할 때 사용
- 변수에도 생애 주기가 있으므로 null값 대신 변수의 생애 주기를 짧게 만드는 것이 더 효율적임



## 10. symbol 타입

- 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키(property key)를 만들기 위해 사용
- 함수를 호출해 사용
- 나중에 자세히 배울 것



## 11. 객체 타입

- 원시 타입과 크게 분류되는 이유는 무엇일까?
  - 근본적으로 두 타입이 다르다는 의미
- 나중에 자세히 배울 것



## 12. 동적 타이핑

### 12.1 동적 타입 언어와 정적 타입 언어

> 자바스크립트의 모든 값은 데이터 타입을 갖는다고 하였는데, 그렇다면 변수는 데이터 타입을 갖을까?

- 정적 타입(Static/Strong type) 언어 : 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언
  - 이를 명시적 타입 선언(explict type declaration)이라 함
  - ex) C나 Java
- 동적 타입 언어는 변수 선언할 때 타입을 지정하지 않음
  - 자바스크립트는 값에만 타입이 존재
  - **변수에 타입이 없다라고 할 수 없고 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다고 표현하는 것이 적절(동치)**

- 동적 타입 언어에는 어떠한 데이터 타입의 값이라도 자유롭게 할당 가능

- 근본적인 차이는 무엇일까?
  - 정적 타입 언어는 엄격한 규칙 하에 변수 타입을 설정하면 아무리 많은 코드가 실행된 후에도 반드시 해당 타입의 값을 가지고 있어야 함
    - 코딩은 어렵지만 안정성이 있음
  - 동적 타입 언어는 어떤 타입의 값이 들어있을지 예측하기 어려움
    - 코딩은 편리하지만 신뢰성이 떨어짐
  - 정적 타입 언어가 훨씬 안정적임(그러므로 TypeScript 인기가 높아지고 있음 -> 그러나 웹브라우저에서 동작하는건 자바스크립트 이므로 결국 자바스크립트로 보여짐)

### 12.2 동적 타입 언어와 변수

- 편리함의 이면에는 위험이 존재
- 모든 소프트웨어 아키텍처에는 트레이드오프(trade-off) 존재
- 재할당이 불가능한 변수 : 상수(수학적 상수와 다름)
- 변수는 재할당이 가능하므로 값이 변할 수 있음
  - 자바스크립트 대부분의 오류는 변수에서 일어남
- 안정적인 프로그램을 만들기 위해서는?
  - 변수의 사용을 적극적으로 줄임
  - 전역 변수(생명주기가 가장 길다)는 사용하지 않음
  - 변수 생명주기(스코프)를 최대한 짧게 만듦
  - 변수보다는 상수를 사용해 값의 변경 억제
  - 변수 이름은 변수의 존재 이유를 파악할 수 있도록 명명
- 변수는 좋은게 아니다...(나중에)



# 6. 연산자

## 1. 표현식과 연산자

- 표현식 : 리터럴, 식별자, 연산자, 함수 호출의 조합으로 평가되어 하나의 값을 만듦
- 표현식은 하나의 값으로 평가될 수 있는 문(**표현식 문**, expression statement)

![](https://poiemaweb.com/assets/fs-images/6-1.png)

- var sum = 100 ; 리터럴도 표현식도 아닌 문
- sum 식별자 표현식

- 10 + 20 표현식, 리터럴은 10, 20 각각 전체가 리터럴은 아님
- 리터럴은 표현식이다, 그러나 표현식 전부가 리터럴인 것은 아님

```javascript
var x = 10 ;
x + 30; // 40
```

- x : 식별자 리터럴, 표현식
- 30 : 숫자 리터럴, 표현식

- x + 30 : 표현식



## 2. 문과 표현식

- 문이 표현식보다 큼
- 문(statement) : 하나 이상의 표현식과 키워드의 조합으로 구성된 자바스크립트 엔진에게 내리는 명령
- 값으로 평가된다 = 변수에 할당할 수 있다

![](https://poiemaweb.com/assets/fs-images/6-2.png)

- var x;는 표현식이 아님(변수에 할당할 수 없으므로)
- 할당문은 표현식인 문임(값으로 평가되고, 다른 변수에 할당할 수 있음)

- 함수 선언문은 변수에 할당할 수 있을까?
  - 변수에 할당할 수 있을 뿐더러, 단독으로 쓰일 때는 표현식이 아닌 문이지만 변수에 할당하는 순간 표현식인 문이 됨(함수 선언문, 함수 표현식...)
- if (x > 5) {console.log(x);} 변수에 할당하면 에러 발생
- 반복문도 변수에 할당하면 에러 발생
- 세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)
  - 문의 끝을 자동으로 인식하여 세미콜론을 생략해도 자동으로 붙여줌

```javascript
function foo () {
  return
    {}
  // ASI의 예측에 의한 해석 => return; {};
}

console.log(foo()); // undefined

var bar = function () {}
(function() {})();
// ASI의 예측에 의한 해석 => var bar = function () {}(function() {})();
// TypeError: (intermediate value)(...) is not a function

```



## 3. 표현식인 문과 표현식이 아닌 문

> 변수에 할당해 보기. 표현식인 문은 값으로 평가되므로 변수에 할당 가능

- 크롬 개발자 도구에서 표현식이 아닌 문은 언제나 undefined를 반환하지만 변수에 할당할 수 없으므로 캐치할 수 없음

- 완료값(Completion value) : 변수에 담을 수 없는 무의미한 값

- 표현식인 문 : 값으로 평가될 수 있음(변수에 할당할 수 있음)

- 표현식이 아닌 문 : 값으로 평가될 수 없음(변수에 할당할 수 없음)



## 4. 연산자란?

- 연산자(Operator) : 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 **하나의 값을 만듦**
  - 반드시 피연산자를 가지고 있어야 함
  - 피연산자로는 표현식이 올 수 있음



## 5. 산술 연산자

- 산술이 불가능한 경우 NaN 반환

### 5.1 이항 산술 연산자

- 피연산자가 2개
- 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지(부수 효과 없음)

### 5.2 단항 산술 연산자

- 피연산자가 1개
- 증가/감소 연산시 피연산자의 값이 변경(부수 효과)

```javascript
var x = 5, result;

// 선할당 후증가 (Postfix increment operator)
result = x++;
console.log(result, x); // 5 6

// 선증가 후할당 (Prefix increment operator)
result = ++x;
console.log(result, x); // 7 7

// 선할당 후감소 (Postfix decrement operator)
result = x--;
console.log(result, x); // 7 6

// 선감소 후할당 (Prefix decrement operator)
result = --x;
console.log(result, x); // 5 5
```

- +, -사용 예(반드시 피연산자를 숫자값으로 변환시키려 함)

```javascript
// + 단항 연산자

// 아무런 효과가 없다.
+10;    // -> 10
+(-10); // -> -10

// 문자열을 숫자로 타입 변환한다.
+'10'; // -> 10

// 불리언 값을 숫자로 타입 변환한다.
+true; // -> 1

// 불리언 값을 숫자로 타입 변환한다.
+false; // -> 0

// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.
+'Hello'; // -> NaN

// - 단항 연산자

// 부호를 반전한다.
-(-10); // -> 10

// 문자열을 숫자로 타입 변환한다.
-'10'; // -> -10

// 불리언 값을 숫자로 타입 변환한다.
-true; // -> -1

// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.
-'Hello'; // -> NaN
```

- 음수를 양수로 바꿀 때 -(-10)보다는 -10*-1이 모양이 훨 좋음



### 5.3 문자열 연결 연산자

- 좌항과 우항이 모두 숫자 타입 : 산술 연산자
- 좌항과 우항중 한쪽이라도 문자열일 경우 : 문자열 연결 연산자

```javascript
// 문자열 연결 연산자
'1' + 2; // -> '12'
1 + '2'; // -> '12'

// 산술 연산자
1 + 2; // -> 3

// true는 1로 타입 변환된다.
1 + true; // -> 2

// false는 0으로 타입 변환된다.
1 + false; // -> 1

// null는 0으로 타입 변환된다.
1 + null; // -> 1

// undefined는 숫자로 타입 변환되지 않는다.
+undefined;    // -> NaN
1 + undefined; // -> NaN
```

- 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion) 발생



## 6. 할당 연산자

- 할당 연산자(Assignment Operator) : 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당(값을 할당하므로 부수 효과 발생)

| 할당 연산자 | 사례   | 동일 표현 | 부수 효과 |
| :---------: | :----- | :-------- | :-------: |
|      =      | x = 5  | x = 5     |     ○     |
|     +=      | x += 5 | x = x + 5 |     ○     |
|     -=      | x -= 5 | x = x - 5 |     ○     |
|     *=      | x *= 5 | x = x * 5 |     ○     |
|     /=      | x /= 5 | x = x / 5 |     ○     |
|     %=      | x %= 5 | x = x % 5 |     ○     |

```javascript
var str = 'My name is ';

// 문자열 연결 연산자
str += 'Lee'; // str = str + 'Lee';

console.log(str); // 'My name is Lee'
```

- 표현식은 하나의 값으로 평가된다고 하였는데, 그렇다면 할당 연산은 표현식인 문일까?

```javascript
var x;

// 할당문은 표현식인 문이다.
console.log(x = 10); // 10
```

- 따라서 할당 연산 표현식을 다른 변수에 할당할 수 있으므로 여러 변수에 동일한 값을 연쇄 할당할 수 있음
  - 비추천 : 오해의 소지 발생, 가독성 좋지 않음

```javascript
var a, b, c;

// 연쇄 할당. 오른쪽에서 왼쪽으로 진행.
// ① c = 0 : 0으로 평가된다
// ② b = 0 : 0으로 평가된다
// ③ a = 0 : 0으로 평가된다
a = b = c = 0;

console.log(a, b, c); // 0 0 0
```



## 7. 비교 연산자

> 아주 중요함

- 비교 연산자(Comparison Operator) : 좌항과 우항의 피연산자를 비교한 다음 불리언 값 반환
  - if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용

### 7.1 동등 / 일치 비교 연산자

- 결론적으로 일치 비교(strict equality) 연산자를 사용하자

| 비교 연산자 | 의미        | 사례    | 설명                     | 부수 효과 |
| :---------: | :---------- | :------ | :----------------------- | :-------: |
|     ==      | 동등 비교   | x == y  | x와 y의 값이 같음        |     ✕     |
|     ===     | 일치 비교   | x === y | x와 y의 값과 타입이 같음 |     ✕     |
|     !=      | 부동등 비교 | x != y  | x와 y의 값이 다름        |     ✕     |
|     !==     | 불일치 비교 | x !== y | x와 y의 값과 타입이 다름 |     ✕     |

```javascript
// 동등 비교
5 == 5; // -> true

// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.
5 == '5'; // -> true
```

- 결과를 예측하기 어렵기 때문에 동등 비교 연산자는 사용하지 않는 편이 좋음

```javascript
// NaN은 자신과 일치하지 않는 유일한 값이다.
NaN === NaN; // -> false
```

- 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용

```javascript
// 빌트인 함수 isNaN은 주어진 값이 NaN인지 체크하고 그 결과를 반환한다.
isNaN(NaN); // -> true
isNaN(10);  // -> false
isNaN(1 + undefined); // -> true
```

- 숫자 0 주의하자. 음의 0은 쓸일이 없음

```javascript
// 양의 0과 음의 0의 비교. 일치 비교/동등 비교 모두 true이다.
0 === -0; // -> true
0 == -0;  // -> true
```



### 7.2 대소 관계 비교 연산자

- 피연산자의 크기를 비교하여 불리언 값 반환



## 8. 삼항 조건 연산자

> 활용도가 높음

- 삼항 조건 연산자(ternary operator) : 조건식의 평가 결과에 따라 반환할 값을 결정(부수효과 없음)
- 하나의 값을 평가하므로 표현식

```javascript
var x = 2;

// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.
var result = x % 2 ? '홀수' : '짝수';

console.log(result); // 짝수
```

- if문을 한줄로 표현 가능할 때 삼항 조건 연산자를 많이 사용
  - if문은 표현식이 아닌 문, 삼항 조건 연산자는 표현식인 문



## 9. 논리 연산자

- 논리 연산자(Logical Operator) : 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산

| 논리 연산자 | 의미        | 부수 효과 |
| :---------: | :---------- | :-------: |
|    \|\|     | 논리합(OR)  |     ✕     |
|     &&      | 논리곱(AND) |     ✕     |
|      !      | 부정(NOT)   |     ✕     |

```javascript
// 암묵적 타입 변환
!0;       // -> true
!'Hello'; // -> false
```

- 논리 부정(!) 연산자는 피연산자가 불리언 값이 아닌 경우 불리언 타입으로 암묵적 타입 변환
  - NaN은 숫자 일때만 출력

```javascript
// 단축 평가
'Cat' && 'Dog'; // -> 'Dog'
```

- 단축 평가
- &&는 좌항과 우항의 값이 모두 true일 때 true인데, 일단 Cat이 true이므로 뒤로 넘어가서 Dog도 true이므로 뒤의값인 Dog이 반환됨
  - true && false 작동 원리 : 좌항이 true이고 다음 false로 넘어왔을 때 true가 아니므로 false값 반환

```javascript
!(x || y) === (!x && !y)
!(x && y) === (!x || !y)
```

- 드 모르간의 법칙 : 좌측의 모양으로 쓰는게 좋음



## 10. 쉼표 연산자

- 쉼표 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고, 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환
- 가독성이 안좋으므로 추천하지 않음



## 11. 그룹 연산자

- 그룹 연산자를 사용하면 연산자의 우선 순위를 조절할 수 있음



## 12. typeof 연산자

- typeof 연산자는 자신의 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환
  - typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 일치하지는 않음

```javascript
typeof ''              // -> "string"
typeof 1               // -> "number"
typeof NaN             // -> "number"
typeof true            // -> "boolean"
typeof undefined       // -> "undefined"
typeof Symbol()        // -> "symbol"
typeof null            // -> "object"
typeof []              // -> "object"
typeof {}              // -> "object"
typeof new Date()      // -> "object" -> 생성자 함수 (표현식)
typeof /test/gi        // -> "object" -> 정규 표현식
typeof function () {}  // -> "function"
```

- 문자열은 0개 이상의 문자의 집합이므로 ''만 있어도 문자열

- null 값 연산시 null이 아닌 object반환하는 것에 주의
  - null값을 확인할 때는 typpeof 연산자를 사용하지 말고 일치 연산자(===)를 사용하도록 할 것

- 함수(function)이라는 type이 있는게 아니고 object에 속하지만, function은 특별 대우



## 13. 지수 연산자

- 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입 값 반환
- 위 방식으로 코딩 후 Babel 이용시 아래 코드로 변환해줌

```javascript
5 ** 2;   // -> 25
5 ** 2.5; // -> 55.90169943749474
5 ** 0;   // -> 1
5 ** -2;  // -> 0.04

// 지수 연산자 도입 이전
Math.pow(5, 2);   // -> 25
Math.pow(5, 2.5); // -> 55.90169943749474
Math.pow(5, 0);   // -> 1
Math.pow(5, -2);  // -> 0.04
```

- 음수 거듭 제곱시 괄호로 묶어야 한다

```javascript
-5 ** 2;
// -> SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence
(-5) ** 2; // -> 25
```

```javascript
var num = 5;
num **= 2; // -> 25

2 * 5 ** 2; // -> 50
```

- 지수 연산자는 모든 이항 연산자보다 우선 순위가 높음





## 수업시간 중 중요한 것

- 증감연산자(++/--)
- 동등 연산자와 일치 연산자의 차이
- 삼항 조건 연산자


러버덕 주제 : 네이밍케이스, 데이터타입, 동적 타이핑