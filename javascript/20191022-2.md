# 22. 실행 컨텍스트

- 실행 컨텍스트(Execution Context) : 식별자, 스코프, 호이스팅, 클로저 등의 동작 원리를 담고 있는 자바스크립트의 핵심 개념

- 실행 컨텍스트를 바르게 이해하면 자바스크립트가 스코프를 기반으로 식별자와 식별자에 바인딩된 값을 관리하는 방식과 호이스팅이 발생하는 이유, 그리고 클로저의 동작 방식에 대해 이해할 수 있음



- 변수 선언을 하면 식별자가 '등록' 된다고 얘기했었음
  - 그렇다면 어디에 등록되는걸까? 실행 컨텍스트
  - 변수에 할당한 값은 어디에 등록되는걸까? 실행 컨텍스트
  - 스코프 관계를 어떻게 구별하는가, 스코프 규칙(아래에서 위로 탐색)은 왜 그렇게 설정되었는가, 호이스팅은 왜 발생하는가, 전역 변수 선언시 window의 프로퍼티가 된다고 했는데 왜 그렇게 되는가, let, const는 왜 전역객체의 프로퍼티가 되지 않느냐
    - 모든 대답을 실행 컨텍스트로 설명할 수 있음

- 자바스크립트 엔진이 소스코드를 파싱해서 AST를 만드는데, 변수를 선언, 할당 등을 하면 그걸 어딘가에 적어놔야함-> 그게바로 실행 컨텍스트
- 함수를 호출하면 코드가 위에서 아래로 가지 않고 왜 위로 가서 함수를 찾는가?
  - 코드의 실행순서가 바뀐다는 이야긴데 자바스크립트는 현재 실행중인 코드가 무엇인지 어떻게 아는가?
    - 실행 컨텍스트를 통해 설명 가능

## 1. 실행 가능한 코드

> 개발자가 작성한 코드는 전부 실행 가능한데 무슨 소리인가? -> ECMAScript에서 말하길 실행 컨텍스트 생성 과정이 다른 코드들을 말하는 것

- ECMAScript 사양은 실행 가능한 코드(Executable Code)를 4가지 유형으로 구분

| 실행 가능한 코드         | 설명                                                         |
| :----------------------- | :----------------------------------------------------------- |
| 전역 코드(Global code)   | 전역에 존재하는 텍스트 코드를 말한다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
| 함수 코드(Function code) | 함수 내부에 존재하는 텍스트 코드를 말한다. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
| eval 코드(Eval code)     | 빌트인 전역 함수인 eval 함수에 인수로 전달된 텍스트 코드를 말한다. |
| 모듈 코드(Module code)   | 모듈 내부에 존재하는 텍스트 코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다. |

- 전통적으로 eval이라는 함수는 금기시되고 있음(with 문법도)
  - 기존의 스코프와 다른 독자적인 스코프를 만듦 -> 사용하지 않으므로 냅두자
- 모듈은 Webpack을 이용해 인위적인 파일 스코프를 만들 것

**우리는 전역 코드와 함수 코드만 배우도록 할 것**

- 전역의 코드 블록 내부는 전역이 아님
  - 함수는 호출이 되면 함수 내부로 들어가서 실행
- 함수 코드는 함수 내부의 코드를 말하는 것으로 중첩된 함수 내부의 코드는 포함되지 않음

![](https://poiemaweb.com/assets/fs-images/22-1.png)

- 실행 가능한 코드들은 실행 컨텍스트를 만듦



## 2. 실행 가능한 코드의 평가와 실행

- 모든 실행 가능한 코드는 실행에 앞서 평가 과정을 거치면서 코드 실행을 위한 준비
  - 평가 단계 : 선언문들을 처리하는 단계(전역에 기술한 변수 선언문, 함수 선언문을 먼저 실행하는 단계)
  - 코드가 평가되면 식별자가 만들어짐 -> 평가결과인 식별자와 값을 실행 컨텍스트에 등록
  - 코드의 평가 단계에서는 변수 x가 선언되고 undefined가 할당, 코드의 실행단계에서는 변수에 값을 할당하는 과정

![](https://poiemaweb.com/assets/fs-images/22-2.png)



## 3. 실행 컨텍스트의 역할

- 자바스크립트 엔진이 예제를 어떻게 실행할지 생각해보자

```javascript
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메소드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메소드 호출
console.log(x + y); // 3
```

- 평가한다 -> 실행문을 먼저 실행한다는 것

- 전역의 변수 x, y와 foo를 전역 실행 컨텍스트에 등록

  - var라면 undefined를 초기화하겠지만 const는 아님
  - const가 선언 후 비워놓을 수 없으므로 뭔가 채워놓긴 하지만 우리는 알 수는 없음(초기화는 하지 않음) -> 할당 이전에 참조하면 레퍼런스 에러 발생

  - uninitialized라고 표현 -> 이 값이 들어가있는게 아니라 초기화되지 않았다는 뜻으로
  - 함수 foo는 정의까지 완료됨

- 함수를 호출하면 함수 내부로 들어가는데, 그러므로 함수 내부의 코드는 포함되지 않음

- 전역 코드 평가가 끝나고 코드 실행 단계 시작

  - x에 1할당하여 초기화, y에 2 할당하여 초기화
    - 초기화란? 값을 처음 할당하는 단계
  - 함수 호출문을 만나 함수문을 평가하기 위해 함수 실행컨텍스트가 생성됨

- 함수 실행 컨텍스트, 함수 내부 평가 시작

  - 변수 x, y, 매개변수 a 호이스팅하여 함수 컨텍스트에 등록
  - 함수코드가 실행되면서 x에 10, y에 20, a에 100 할당
  - console.log하려면 console을 찾아야 하므로 함수 foo내부에 console을 찾음(없음) -> 전역에서 찾음(있음)
  - 이제 log를 찾는데 console의 프로토타입 체인에서 찾음
    - log는 인스턴스 메소드
  - a + x + y를 평가하기 위해 a 식별자부터 지역변수내부(함수 실행 컨텍스트)에서 찾는데, a는 매개변수이므로 var취급. 찾았으므로 스코프 체인을 타고 올라가지 않고 x, y를 찾음. 함수 내부에서 모두 찾았으므로 연산 후 값을 평가하여 인수로 전달(130 전달)
  - 생략된 return undefined를 반환하면서 함수 종료

-  **실행 컨텍스트(Execution Context)는 : 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고, 코드의 실행 결과를 실제로 관리하는 영역**



## 4. 실행 컨텍스트 스택

```javascript
const x = 1;

function foo () {
  const y = 2;

  function bar () {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```

- 실행 컨텍스트 스택에서 가장 위에 있는 스택을 실행 컨텐스트 스택(= 콜 스택)이라고 표현

- 다 실행된 후(함수 호출 종료) 모든 함수 실행컨텍스트가 빠져나가면 전역 컨텍스트로 나감

> 실행 컨텍스트 스택

![](https://poiemaweb.com/assets/fs-images/22-3.png)

- 실행 컨텍스트 스택을 통해 현재 실행중인 코드가 무엇인지, 어디로 돌아가야 하는지를 파악할 수 있음



## 5. 동기식 처리 모델과 비동기식 처리 모델

- 자바스크립트 엔진에는 단 하나의 실행 컨텍스트 스택 존재
  - 한 번에 일을 하나밖에 못 한다는 것을 의미
  - 싱글 스레드(single thread)

- 하나의 일이 끝나고 다음일을 하면, 서버가 답변해줄 때까지 기다리면 블로킹이 발생하므로 대기 시간을 없애버리도록 해야 함
  - **동기식 처리 모델(Synchronous processing model)** : 하나의 처리가 종료되어야 다음 처리를 실행할 수 있는 것

![](https://poiemaweb.com/assets/fs-images/22-4.png)

- 자바스크립트는 다행히 **비동기식 처리 모델(Asynchronous processing model 또는 Non-Blocking processing model)**
- 요청하고 응답이 올 때까지 기다리지 않고 바로 다른 일을 실행함

![](https://poiemaweb.com/assets/fs-images/22-5.png)

- 비동기식 처리 모델은 가독성이 나빠지고 콜백 방식을 써야함
  - 비동기로 돌기 때문에 A라는 언제 끝날지 모르므로 B를 바로 같이 실행해버리는 와중에도 콜백으로 받은 함수에도 바로 인자로 넘겨버림 -> 콜백 헬 발생
  - 이를 해결하기 위해 프로미스라는 방식을 도입(나중에)

- 그럼에도 비동기식 처리 모델을 사용하는 이유는 싱글 스레드인 자바스크립트 엔진에서 동시성을 구현하기 위해서



## 6. 렉시컬 환경

- 식별자가 선언되는 실제 환경
  - 실행 컨텍스트 자료 구조가 렉시컬 환경으로 이루어져 있음

- 자바스크립트의 모든 스코프는 렉시컬 스코프
  - 렉시컬 스코프에는 스코프가 등록됨

- 스코프체인은 실제로는 렉시컬 스코프의 연결!

- 실행 컨텍스트와 렉시컬 환경의 관계

![](https://poiemaweb.com/assets/fs-images/22-6.png)

- 실행 컨텍스트는 LexicalEnvironment라는 프로퍼티(컴포넌트)와 VariableEnvironment라는 프로퍼티(컴포넌트)로 구성

![](https://poiemaweb.com/assets/fs-images/22-7.png)

![](https://poiemaweb.com/assets/fs-images/22-8.png) 

- 환경 레코드에는 스코프에 포함된 식별자를 등록하고 식별자에 바인딩된 값을 관리하는 저장소
- 참조값은 상위 스코프를 가리킴

- ThisBinding에는 this값



## 7. 실행 컨텍스트의 생성과 식별자 검색 과정

```javascript
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}

foo(20); // 42
```

- 전역에는 식별자 x, y, foo만 등록 -> 객체 환경 레코드에 등록

![](https://poiemaweb.com/assets/fs-images/22-10.png)

- 전역 컨텍스트는 항상 맨 밑바닥
- 전역 컨텍스트 환경의 렉시컬 환경이므로 전역 렉시컬 환경이라 부름
  - 전역환경레코드, 외부 렉시컬 환경에 대한 참조(전역 렉시컬 환경인 경우에는 null이 들어가야함, 상위가 존재하지 않으므로), ThisBinding을 가짐
  - 전역 렉시컬 환경은 프로퍼티 두개(Object Environment Record), (Declarative Environment Record)
    - var로 선언한 건 Object Environment Record 여기에 들어가 있음 -> 이것은 전역 객체로 이어져서 초기화됨
    - const로 선언한 건 Declarative Environment Record로 들어가서 초기화되지 않음
    - foo는 Object Environment Record로 들어가서 전액 객체로 이어지고 초기화됨
    - 그러므로 전역 실행 컨텍스트가 만들어지기 이전에 전역객체(window)가 가장 먼저 만들어져 있음

- 전역 스코프의 상위 스코프는 존재하지 않음

![](https://poiemaweb.com/assets/fs-images/22-15.png)

- 전역의 this는 전역객체 window

![](https://poiemaweb.com/assets/fs-images/22-16.png)

### 7.3 전역 코드 실행

![](https://poiemaweb.com/assets/fs-images/22-17.png)

- 전역 코드가 실행되고 foo 함수 호출이 시작되면 함수 실행컨텍스트가 쌓임



### 7.4 foo 함수 코드 평가

![](https://poiemaweb.com/assets/fs-images/22-18.png)

- foo함수 실행 컨텍스트가 위에 쌓이고 이 함수도 렉시컬 환경을 가지고 있는데, 전역과 구조가 똑같음
- 외부 렉시컬 환경에 대한 참조는 전역 렉시컬 환경으로 이어짐
- 함수환경레코드로 이어지면 매개변수, arguments, 지역변수, 지역 함수들이 저장
- 전역과 함수 렉시컬 환경의 차이는 window와 이어지게 되어 있느냐, 없느냐의 차이
  - var키워드로 선언된 함수는 window의 프로퍼티가 됨...

![](https://poiemaweb.com/assets/fs-images/22-23.png)

![](https://poiemaweb.com/assets/fs-images/22-25.png)

- 매개변수의 값으로는 인수가 들어오고
- 지역변수들은 할당문에 의해 값이 채워지고
- **주의할 것 : 외부(상위) 렉시컬 환경의 참조는 전역 렉시컬 환경을 가리킴**

- 코드가 있는 곳은 현재 실행중인 실행 컨텍스트에서부터 찾음
  - 현재 bar가 가장 최상위, 여기서 bar 렉시컬 환경으로 이동하여 찾음
  - 없으면 OuterLexicalEnvironmentReference를 통해 상위로 이동

- 주의할 것 : 실행 컨텍스트에 쌓여진 것들이 사라질뿐 렉시컬 환경과 환경 레코드는 사라지지 않음
  - 가비지 컬렉터의 대상은 될 수 있지만 무언가가 렉시컬 환경과 환경 레코드를 바라보고 있으면 삭제되지 않음
  - bar 실행 컨텍스트가 사라지고 아무도 bar 렉시컬 환경을 바라보지 않으면 렉시컬 환경이 사라지고 그러면 bar 함수 환경 레코드도 사라짐
    - 사라지지 않도록 하는 것이 클로저
  - window는 전역 코드가 종료되어도 브라우저를 닫기 전에는 사라지지 않음(나머진 다 사라질 수 있음)
    - 그래서 const, let으로 선언한 것들은 전역에 선언해도 죽을 수 있음
    - var키워드 선언이나 함수선언문은 window와 생명주기를 같이 함



## 8. 실행 컨텍스트와 블록 레벨 스코프

```javascript
let x = 1;

if (true) {
  let x = 10;
  console.log(x); // 10
}

console.log(x); // 1
```

- 실행 컨텍스트는 오로지 전역, 함수, eval, 모듈만 만듦
- 그렇지만 저 네가지를 제외한 나머지도 스코프는 만듦

![](https://poiemaweb.com/assets/fs-images/22-29.png)

- if문이 종료되면 블록렉시컬 환경에서 전역 렉시컬 환경으로 화살표가 이동

![](https://poiemaweb.com/assets/fs-images/22-30.png)

- if문 내부에서 var로 선언시 블록레벨스코프가 만들어지지 않음!



- Object Environment Record는 왜 필요한가?
  - var키워드로 선언한 전역변수는 윈도우에 들어가있음
  - 우리가 bar함수 내부에서 x를 참조하면 거기엔 x가 없으므로 외부렉시컬환경타고 내려와서(foo에도 없고 전역에만 있다고 가정) Declarative Environment Record이랑 window에서 찾는데 둘 모두에 있을 수는 없음!!! Declarative Environment Record에서 window로 바로갈 수 없으므로 Object Environment Record가 중간에서 중개 역할을 함
    - Object Environment Record이 환경에 따라 적당한 전역을 찾아감
    - window가 아닐수도 있음(Node.js에서는 global)

